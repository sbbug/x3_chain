// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#include "common.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_common_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CameraMatrix_common_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_common_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Color_common_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_common_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DistortParam_common_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_common_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ObstacleRaw_common_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_common_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Rect_common_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_common_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_VCSParam_common_2eproto;
namespace CommonProto {
class RectDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Rect> _instance;
} _Rect_default_instance_;
class ImageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Image> _instance;
} _Image_default_instance_;
class ObstacleRawDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ObstacleRaw> _instance;
} _ObstacleRaw_default_instance_;
class ObstacleRawsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ObstacleRaws> _instance;
} _ObstacleRaws_default_instance_;
class CameraMatrixDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CameraMatrix> _instance;
} _CameraMatrix_default_instance_;
class DistortParamDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DistortParam> _instance;
} _DistortParam_default_instance_;
class VCSParamDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<VCSParam> _instance;
} _VCSParam_default_instance_;
class CameraParamDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CameraParam> _instance;
} _CameraParam_default_instance_;
class ColorDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Color> _instance;
} _Color_default_instance_;
class ParsingSettingDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ParsingSetting> _instance;
} _ParsingSetting_default_instance_;
}  // namespace CommonProto
static void InitDefaultsscc_info_CameraMatrix_common_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::CommonProto::_CameraMatrix_default_instance_;
    new (ptr) ::CommonProto::CameraMatrix();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::CommonProto::CameraMatrix::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CameraMatrix_common_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_CameraMatrix_common_2eproto}, {}};

static void InitDefaultsscc_info_CameraParam_common_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::CommonProto::_CameraParam_default_instance_;
    new (ptr) ::CommonProto::CameraParam();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::CommonProto::CameraParam::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_CameraParam_common_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsscc_info_CameraParam_common_2eproto}, {
      &scc_info_DistortParam_common_2eproto.base,
      &scc_info_VCSParam_common_2eproto.base,
      &scc_info_CameraMatrix_common_2eproto.base,}};

static void InitDefaultsscc_info_Color_common_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::CommonProto::_Color_default_instance_;
    new (ptr) ::CommonProto::Color();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::CommonProto::Color::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Color_common_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Color_common_2eproto}, {}};

static void InitDefaultsscc_info_DistortParam_common_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::CommonProto::_DistortParam_default_instance_;
    new (ptr) ::CommonProto::DistortParam();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::CommonProto::DistortParam::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DistortParam_common_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_DistortParam_common_2eproto}, {}};

static void InitDefaultsscc_info_Image_common_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::CommonProto::_Image_default_instance_;
    new (ptr) ::CommonProto::Image();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::CommonProto::Image::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Image_common_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Image_common_2eproto}, {}};

static void InitDefaultsscc_info_ObstacleRaw_common_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::CommonProto::_ObstacleRaw_default_instance_;
    new (ptr) ::CommonProto::ObstacleRaw();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::CommonProto::ObstacleRaw::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ObstacleRaw_common_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_ObstacleRaw_common_2eproto}, {
      &scc_info_Rect_common_2eproto.base,}};

static void InitDefaultsscc_info_ObstacleRaws_common_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::CommonProto::_ObstacleRaws_default_instance_;
    new (ptr) ::CommonProto::ObstacleRaws();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::CommonProto::ObstacleRaws::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ObstacleRaws_common_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_ObstacleRaws_common_2eproto}, {
      &scc_info_ObstacleRaw_common_2eproto.base,}};

static void InitDefaultsscc_info_ParsingSetting_common_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::CommonProto::_ParsingSetting_default_instance_;
    new (ptr) ::CommonProto::ParsingSetting();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::CommonProto::ParsingSetting::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ParsingSetting_common_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_ParsingSetting_common_2eproto}, {
      &scc_info_Color_common_2eproto.base,}};

static void InitDefaultsscc_info_Rect_common_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::CommonProto::_Rect_default_instance_;
    new (ptr) ::CommonProto::Rect();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::CommonProto::Rect::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Rect_common_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Rect_common_2eproto}, {}};

static void InitDefaultsscc_info_VCSParam_common_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::CommonProto::_VCSParam_default_instance_;
    new (ptr) ::CommonProto::VCSParam();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::CommonProto::VCSParam::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_VCSParam_common_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_VCSParam_common_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_common_2eproto[10];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_common_2eproto[4];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_common_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_common_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CommonProto::Rect, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::Rect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CommonProto::Rect, left_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::Rect, top_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::Rect, right_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::Rect, bottom_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CommonProto::Image, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::Image, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CommonProto::Image, width_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::Image, height_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::Image, channel_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::Image, time_stamp_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::Image, send_mode_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::Image, format_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::Image, index_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::Image, count_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::Image, depth_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::Image, align_),
  0,
  1,
  3,
  2,
  4,
  5,
  6,
  7,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::CommonProto::ObstacleRaw, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::ObstacleRaw, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CommonProto::ObstacleRaw, rect_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::ObstacleRaw, conf_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::ObstacleRaw, model_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::ObstacleRaw, source_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::ObstacleRaw, property_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::ObstacleRaw, property_name_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::ObstacleRaw, property_type_),
  0,
  1,
  2,
  3,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CommonProto::ObstacleRaws, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::ObstacleRaws, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CommonProto::ObstacleRaws, cam_id_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::ObstacleRaws, obstacle_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::ObstacleRaws, conf_scale_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraMatrix, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraMatrix, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraMatrix, mat_gnd2img_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraMatrix, mat_img2gnd_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraMatrix, mat_vcsgnd2img_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraMatrix, mat_img2vcsgnd_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CommonProto::DistortParam, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::DistortParam, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CommonProto::DistortParam, param_),
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CommonProto::VCSParam, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::VCSParam, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CommonProto::VCSParam, rotation_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::VCSParam, translation_),
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraParam, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraParam, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraParam, focal_u_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraParam, focal_v_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraParam, center_u_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraParam, center_v_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraParam, camera_x_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraParam, camera_y_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraParam, camera_z_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraParam, pitch_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraParam, yaw_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraParam, roll_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraParam, type_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraParam, fov_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraParam, distort_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraParam, vcs_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::CameraParam, mat_),
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CommonProto::Color, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::Color, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CommonProto::Color, b_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::Color, g_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::Color, r_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CommonProto::ParsingSetting, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::ParsingSetting, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CommonProto::ParsingSetting, parsing_type_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::ParsingSetting, parsing_channels_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::ParsingSetting, channel_labels_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::ParsingSetting, channel_colors_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::ParsingSetting, freespace_channels_),
  PROTOBUF_FIELD_OFFSET(::CommonProto::ParsingSetting, boundspace_channels_),
  0,
  1,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, sizeof(::CommonProto::Rect)},
  { 13, 28, sizeof(::CommonProto::Image)},
  { 38, 50, sizeof(::CommonProto::ObstacleRaw)},
  { 57, 65, sizeof(::CommonProto::ObstacleRaws)},
  { 68, 77, sizeof(::CommonProto::CameraMatrix)},
  { 81, 87, sizeof(::CommonProto::DistortParam)},
  { 88, 95, sizeof(::CommonProto::VCSParam)},
  { 97, 117, sizeof(::CommonProto::CameraParam)},
  { 132, 140, sizeof(::CommonProto::Color)},
  { 143, 154, sizeof(::CommonProto::ParsingSetting)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::CommonProto::_Rect_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::CommonProto::_Image_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::CommonProto::_ObstacleRaw_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::CommonProto::_ObstacleRaws_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::CommonProto::_CameraMatrix_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::CommonProto::_DistortParam_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::CommonProto::_VCSParam_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::CommonProto::_CameraParam_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::CommonProto::_Color_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::CommonProto::_ParsingSetting_default_instance_),
};

const char descriptor_table_protodef_common_2eproto[] =
  "\n\014common.proto\022\013CommonProto\"@\n\004Rect\022\014\n\004l"
  "eft\030\001 \002(\002\022\013\n\003top\030\002 \002(\002\022\r\n\005right\030\003 \002(\002\022\016\n"
  "\006bottom\030\004 \002(\002\"\252\001\n\005Image\022\r\n\005width\030\001 \002(\005\022\016"
  "\n\006height\030\002 \002(\005\022\017\n\007channel\030\003 \002(\005\022\022\n\ntime_"
  "stamp\030\004 \001(\003\022\021\n\tsend_mode\030\005 \001(\005\022\016\n\006format"
  "\030\006 \001(\005\022\r\n\005index\030\007 \001(\005\022\r\n\005count\030\010 \001(\005\022\r\n\005"
  "depth\030\t \001(\005\022\r\n\005align\030\n \001(\005\"\233\001\n\013ObstacleR"
  "aw\022\037\n\004rect\030\001 \002(\0132\021.CommonProto.Rect\022\014\n\004c"
  "onf\030\002 \002(\002\022\r\n\005model\030\003 \002(\005\022\016\n\006source\030\004 \001(\005"
  "\022\020\n\010property\030\006 \003(\005\022\025\n\rproperty_name\030\007 \003("
  "\t\022\025\n\rproperty_type\030\010 \003(\005\"c\n\014ObstacleRaws"
  "\022\016\n\006cam_id\030\001 \001(\005\022*\n\010obstacle\030\002 \003(\0132\030.Com"
  "monProto.ObstacleRaw\022\027\n\nconf_scale\030\003 \001(\002"
  ":\0030.1\"h\n\014CameraMatrix\022\023\n\013mat_gnd2img\030\001 \003"
  "(\002\022\023\n\013mat_img2gnd\030\002 \003(\002\022\026\n\016mat_vcsgnd2im"
  "g\030\003 \003(\002\022\026\n\016mat_img2vcsgnd\030\004 \003(\002\"\035\n\014Disto"
  "rtParam\022\r\n\005param\030\001 \003(\002\"1\n\010VCSParam\022\020\n\010ro"
  "tation\030\001 \003(\002\022\023\n\013translation\030\002 \003(\002\"\311\002\n\013Ca"
  "meraParam\022\017\n\007focal_u\030\001 \002(\002\022\017\n\007focal_v\030\002 "
  "\002(\002\022\020\n\010center_u\030\003 \002(\002\022\020\n\010center_v\030\004 \002(\002\022"
  "\020\n\010camera_x\030\005 \002(\002\022\020\n\010camera_y\030\006 \002(\002\022\020\n\010c"
  "amera_z\030\007 \002(\002\022\r\n\005pitch\030\010 \002(\002\022\013\n\003yaw\030\t \002("
  "\002\022\014\n\004roll\030\n \002(\002\022\017\n\004type\030\013 \001(\005:\0010\022\013\n\003fov\030"
  "\014 \001(\002\022*\n\007distort\030\024 \001(\0132\031.CommonProto.Dis"
  "tortParam\022\"\n\003vcs\030\025 \001(\0132\025.CommonProto.VCS"
  "Param\022&\n\003mat\030\036 \001(\0132\031.CommonProto.CameraM"
  "atrix\"(\n\005Color\022\t\n\001b\030\001 \002(\r\022\t\n\001g\030\002 \002(\r\022\t\n\001"
  "r\030\003 \002(\r\"\275\001\n\016ParsingSetting\022\024\n\014parsing_ty"
  "pe\030\001 \002(\005\022\030\n\020parsing_channels\030\002 \002(\005\022\026\n\016ch"
  "annel_labels\030\003 \003(\004\022*\n\016channel_colors\030\004 \003"
  "(\0132\022.CommonProto.Color\022\032\n\022freespace_chan"
  "nels\030\005 \003(\005\022\033\n\023boundspace_channels\030\006 \003(\005*"
  "h\n\013ImageFormat\022\010\n\004GRAY\020\000\022\010\n\004YV12\020\001\022\010\n\004JP"
  "EG\020\002\022\007\n\003PNG\020\003\022\010\n\004CR12\020\004\022\007\n\003BAD\020\005\022\010\n\004NV12"
  "\020\006\022\010\n\004NV21\020\007\022\013\n\007TIMEOUT\020\010*\\\n\rParsingForm"
  "at\022\025\n\021ParsingFormat_Raw\020\000\022\027\n\023ParsingForm"
  "at_Label\020\001\022\033\n\027ParsingFormat_Label_RLE\020\002*"
  "\273\002\n\024ObstacleRawModelType\022\030\n\024ObstacleRawM"
  "odel_Car\020\000\022\034\n\030ObstacleRawModel_FullCar\020\001"
  "\022\030\n\024ObstacleRawModel_Ped\020\002\022\031\n\025ObstacleRa"
  "wModel_Head\020\003\022\031\n\025ObstacleRawModel_Rare\020\004"
  "\022 \n\034ObstacleRawModel_TrafficSign\020\005\022!\n\035Ob"
  "stacleRawModel_TrafficLight\020\006\022\031\n\025Obstacl"
  "eRawModel_Lane\020\007\022\035\n\031ObstacleRawModel_Roa"
  "dSign\020\n\022\034\n\030ObstacleRawModel_Cyclist\020\020*<\n"
  "\nCameraType\022\026\n\022CameraType_PinHole\020\000\022\026\n\022C"
  "ameraType_FishEye\020\001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_common_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_common_2eproto_sccs[10] = {
  &scc_info_CameraMatrix_common_2eproto.base,
  &scc_info_CameraParam_common_2eproto.base,
  &scc_info_Color_common_2eproto.base,
  &scc_info_DistortParam_common_2eproto.base,
  &scc_info_Image_common_2eproto.base,
  &scc_info_ObstacleRaw_common_2eproto.base,
  &scc_info_ObstacleRaws_common_2eproto.base,
  &scc_info_ParsingSetting_common_2eproto.base,
  &scc_info_Rect_common_2eproto.base,
  &scc_info_VCSParam_common_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_common_2eproto_once;
static bool descriptor_table_common_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_common_2eproto = {
  &descriptor_table_common_2eproto_initialized, descriptor_table_protodef_common_2eproto, "common.proto", 1859,
  &descriptor_table_common_2eproto_once, descriptor_table_common_2eproto_sccs, descriptor_table_common_2eproto_deps, 10, 0,
  schemas, file_default_instances, TableStruct_common_2eproto::offsets,
  file_level_metadata_common_2eproto, 10, file_level_enum_descriptors_common_2eproto, file_level_service_descriptors_common_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_common_2eproto = (  ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_common_2eproto), true);
namespace CommonProto {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImageFormat_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_common_2eproto);
  return file_level_enum_descriptors_common_2eproto[0];
}
bool ImageFormat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ParsingFormat_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_common_2eproto);
  return file_level_enum_descriptors_common_2eproto[1];
}
bool ParsingFormat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ObstacleRawModelType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_common_2eproto);
  return file_level_enum_descriptors_common_2eproto[2];
}
bool ObstacleRawModelType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 10:
    case 16:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CameraType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_common_2eproto);
  return file_level_enum_descriptors_common_2eproto[3];
}
bool CameraType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void Rect::InitAsDefaultInstance() {
}
class Rect::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<Rect>()._has_bits_);
  static void set_has_left(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_top(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_right(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bottom(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Rect::kLeftFieldNumber;
const int Rect::kTopFieldNumber;
const int Rect::kRightFieldNumber;
const int Rect::kBottomFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Rect::Rect()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.Rect)
}
Rect::Rect(const Rect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&left_, &from.left_,
    static_cast<size_t>(reinterpret_cast<char*>(&bottom_) -
    reinterpret_cast<char*>(&left_)) + sizeof(bottom_));
  // @@protoc_insertion_point(copy_constructor:CommonProto.Rect)
}

void Rect::SharedCtor() {
  ::memset(&left_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&bottom_) -
      reinterpret_cast<char*>(&left_)) + sizeof(bottom_));
}

Rect::~Rect() {
  // @@protoc_insertion_point(destructor:CommonProto.Rect)
  SharedDtor();
}

void Rect::SharedDtor() {
}

void Rect::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Rect& Rect::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Rect_common_2eproto.base);
  return *internal_default_instance();
}


void Rect::Clear() {
// @@protoc_insertion_point(message_clear_start:CommonProto.Rect)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&left_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&bottom_) -
        reinterpret_cast<char*>(&left_)) + sizeof(bottom_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Rect::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required float left = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          HasBitSetters::set_has_left(&has_bits);
          left_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float top = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          HasBitSetters::set_has_top(&has_bits);
          top_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float right = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          HasBitSetters::set_has_right(&has_bits);
          right_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float bottom = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          HasBitSetters::set_has_bottom(&has_bits);
          bottom_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Rect::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.Rect)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float left = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (13 & 0xFF)) {
          HasBitSetters::set_has_left(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &left_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float top = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_top(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &top_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float right = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_right(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &right_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float bottom = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (37 & 0xFF)) {
          HasBitSetters::set_has_bottom(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &bottom_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.Rect)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.Rect)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Rect::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.Rect)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required float left = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(1, this->left(), output);
  }

  // required float top = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(2, this->top(), output);
  }

  // required float right = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(3, this->right(), output);
  }

  // required float bottom = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(4, this->bottom(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.Rect)
}

::PROTOBUF_NAMESPACE_ID::uint8* Rect::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.Rect)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required float left = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->left(), target);
  }

  // required float top = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->top(), target);
  }

  // required float right = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->right(), target);
  }

  // required float bottom = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->bottom(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.Rect)
  return target;
}

size_t Rect::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:CommonProto.Rect)
  size_t total_size = 0;

  if (has_left()) {
    // required float left = 1;
    total_size += 1 + 4;
  }

  if (has_top()) {
    // required float top = 2;
    total_size += 1 + 4;
  }

  if (has_right()) {
    // required float right = 3;
    total_size += 1 + 4;
  }

  if (has_bottom()) {
    // required float bottom = 4;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t Rect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CommonProto.Rect)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required float left = 1;
    total_size += 1 + 4;

    // required float top = 2;
    total_size += 1 + 4;

    // required float right = 3;
    total_size += 1 + 4;

    // required float bottom = 4;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Rect::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CommonProto.Rect)
  GOOGLE_DCHECK_NE(&from, this);
  const Rect* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Rect>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CommonProto.Rect)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CommonProto.Rect)
    MergeFrom(*source);
  }
}

void Rect::MergeFrom(const Rect& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CommonProto.Rect)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      left_ = from.left_;
    }
    if (cached_has_bits & 0x00000002u) {
      top_ = from.top_;
    }
    if (cached_has_bits & 0x00000004u) {
      right_ = from.right_;
    }
    if (cached_has_bits & 0x00000008u) {
      bottom_ = from.bottom_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Rect::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CommonProto.Rect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Rect::CopyFrom(const Rect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CommonProto.Rect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Rect::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  return true;
}

void Rect::Swap(Rect* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Rect::InternalSwap(Rect* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(left_, other->left_);
  swap(top_, other->top_);
  swap(right_, other->right_);
  swap(bottom_, other->bottom_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Rect::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Image::InitAsDefaultInstance() {
}
class Image::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<Image>()._has_bits_);
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_time_stamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_send_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_format(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_depth(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_align(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Image::kWidthFieldNumber;
const int Image::kHeightFieldNumber;
const int Image::kChannelFieldNumber;
const int Image::kTimeStampFieldNumber;
const int Image::kSendModeFieldNumber;
const int Image::kFormatFieldNumber;
const int Image::kIndexFieldNumber;
const int Image::kCountFieldNumber;
const int Image::kDepthFieldNumber;
const int Image::kAlignFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Image::Image()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.Image)
}
Image::Image(const Image& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&width_, &from.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&align_) -
    reinterpret_cast<char*>(&width_)) + sizeof(align_));
  // @@protoc_insertion_point(copy_constructor:CommonProto.Image)
}

void Image::SharedCtor() {
  ::memset(&width_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&align_) -
      reinterpret_cast<char*>(&width_)) + sizeof(align_));
}

Image::~Image() {
  // @@protoc_insertion_point(destructor:CommonProto.Image)
  SharedDtor();
}

void Image::SharedDtor() {
}

void Image::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Image& Image::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Image_common_2eproto.base);
  return *internal_default_instance();
}


void Image::Clear() {
// @@protoc_insertion_point(message_clear_start:CommonProto.Image)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&count_) -
        reinterpret_cast<char*>(&width_)) + sizeof(count_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&depth_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&align_) -
        reinterpret_cast<char*>(&depth_)) + sizeof(align_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Image::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required int32 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          HasBitSetters::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 channel = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_channel(&has_bits);
          channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 time_stamp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_time_stamp(&has_bits);
          time_stamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 send_mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          HasBitSetters::set_has_send_mode(&has_bits);
          send_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 format = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          HasBitSetters::set_has_format(&has_bits);
          format_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 index = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          HasBitSetters::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 count = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          HasBitSetters::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 depth = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          HasBitSetters::set_has_depth(&has_bits);
          depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 align = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          HasBitSetters::set_has_align(&has_bits);
          align_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Image::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.Image)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 width = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_width(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 height = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_height(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 channel = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_channel(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &channel_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 time_stamp = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_time_stamp(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_stamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 send_mode = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_send_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &send_mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 format = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_format(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &format_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 index = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_index(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 count = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_count(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 depth = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_depth(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &depth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 align = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          HasBitSetters::set_has_align(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &align_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.Image)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.Image)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Image::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.Image)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 width = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->width(), output);
  }

  // required int32 height = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->height(), output);
  }

  // required int32 channel = 3;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->channel(), output);
  }

  // optional int64 time_stamp = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->time_stamp(), output);
  }

  // optional int32 send_mode = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->send_mode(), output);
  }

  // optional int32 format = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->format(), output);
  }

  // optional int32 index = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(7, this->index(), output);
  }

  // optional int32 count = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(8, this->count(), output);
  }

  // optional int32 depth = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(9, this->depth(), output);
  }

  // optional int32 align = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(10, this->align(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.Image)
}

::PROTOBUF_NAMESPACE_ID::uint8* Image::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.Image)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 width = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->width(), target);
  }

  // required int32 height = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->height(), target);
  }

  // required int32 channel = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->channel(), target);
  }

  // optional int64 time_stamp = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->time_stamp(), target);
  }

  // optional int32 send_mode = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->send_mode(), target);
  }

  // optional int32 format = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->format(), target);
  }

  // optional int32 index = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->index(), target);
  }

  // optional int32 count = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->count(), target);
  }

  // optional int32 depth = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->depth(), target);
  }

  // optional int32 align = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(10, this->align(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.Image)
  return target;
}

size_t Image::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:CommonProto.Image)
  size_t total_size = 0;

  if (has_width()) {
    // required int32 width = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->width());
  }

  if (has_height()) {
    // required int32 height = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->height());
  }

  if (has_channel()) {
    // required int32 channel = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->channel());
  }

  return total_size;
}
size_t Image::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CommonProto.Image)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000000b) ^ 0x0000000b) == 0) {  // All required fields are present.
    // required int32 width = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->width());

    // required int32 height = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->height());

    // required int32 channel = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->channel());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int64 time_stamp = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->time_stamp());
  }

  if (cached_has_bits & 0x000000f0u) {
    // optional int32 send_mode = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->send_mode());
    }

    // optional int32 format = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->format());
    }

    // optional int32 index = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional int32 count = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->count());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int32 depth = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->depth());
    }

    // optional int32 align = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->align());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Image::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CommonProto.Image)
  GOOGLE_DCHECK_NE(&from, this);
  const Image* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Image>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CommonProto.Image)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CommonProto.Image)
    MergeFrom(*source);
  }
}

void Image::MergeFrom(const Image& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CommonProto.Image)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000002u) {
      height_ = from.height_;
    }
    if (cached_has_bits & 0x00000004u) {
      time_stamp_ = from.time_stamp_;
    }
    if (cached_has_bits & 0x00000008u) {
      channel_ = from.channel_;
    }
    if (cached_has_bits & 0x00000010u) {
      send_mode_ = from.send_mode_;
    }
    if (cached_has_bits & 0x00000020u) {
      format_ = from.format_;
    }
    if (cached_has_bits & 0x00000040u) {
      index_ = from.index_;
    }
    if (cached_has_bits & 0x00000080u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      depth_ = from.depth_;
    }
    if (cached_has_bits & 0x00000200u) {
      align_ = from.align_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Image::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CommonProto.Image)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Image::CopyFrom(const Image& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CommonProto.Image)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000b) != 0x0000000b) return false;
  return true;
}

void Image::Swap(Image* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Image::InternalSwap(Image* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(width_, other->width_);
  swap(height_, other->height_);
  swap(time_stamp_, other->time_stamp_);
  swap(channel_, other->channel_);
  swap(send_mode_, other->send_mode_);
  swap(format_, other->format_);
  swap(index_, other->index_);
  swap(count_, other->count_);
  swap(depth_, other->depth_);
  swap(align_, other->align_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Image::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ObstacleRaw::InitAsDefaultInstance() {
  ::CommonProto::_ObstacleRaw_default_instance_._instance.get_mutable()->rect_ = const_cast< ::CommonProto::Rect*>(
      ::CommonProto::Rect::internal_default_instance());
}
class ObstacleRaw::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<ObstacleRaw>()._has_bits_);
  static const ::CommonProto::Rect& rect(const ObstacleRaw* msg);
  static void set_has_rect(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_conf(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_model(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CommonProto::Rect&
ObstacleRaw::HasBitSetters::rect(const ObstacleRaw* msg) {
  return *msg->rect_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ObstacleRaw::kRectFieldNumber;
const int ObstacleRaw::kConfFieldNumber;
const int ObstacleRaw::kModelFieldNumber;
const int ObstacleRaw::kSourceFieldNumber;
const int ObstacleRaw::kPropertyFieldNumber;
const int ObstacleRaw::kPropertyNameFieldNumber;
const int ObstacleRaw::kPropertyTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObstacleRaw::ObstacleRaw()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.ObstacleRaw)
}
ObstacleRaw::ObstacleRaw(const ObstacleRaw& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      property_(from.property_),
      property_name_(from.property_name_),
      property_type_(from.property_type_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_rect()) {
    rect_ = new ::CommonProto::Rect(*from.rect_);
  } else {
    rect_ = nullptr;
  }
  ::memcpy(&conf_, &from.conf_,
    static_cast<size_t>(reinterpret_cast<char*>(&source_) -
    reinterpret_cast<char*>(&conf_)) + sizeof(source_));
  // @@protoc_insertion_point(copy_constructor:CommonProto.ObstacleRaw)
}

void ObstacleRaw::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ObstacleRaw_common_2eproto.base);
  ::memset(&rect_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&source_) -
      reinterpret_cast<char*>(&rect_)) + sizeof(source_));
}

ObstacleRaw::~ObstacleRaw() {
  // @@protoc_insertion_point(destructor:CommonProto.ObstacleRaw)
  SharedDtor();
}

void ObstacleRaw::SharedDtor() {
  if (this != internal_default_instance()) delete rect_;
}

void ObstacleRaw::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ObstacleRaw& ObstacleRaw::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ObstacleRaw_common_2eproto.base);
  return *internal_default_instance();
}


void ObstacleRaw::Clear() {
// @@protoc_insertion_point(message_clear_start:CommonProto.ObstacleRaw)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  property_.Clear();
  property_name_.Clear();
  property_type_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(rect_ != nullptr);
    rect_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&conf_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&source_) -
        reinterpret_cast<char*>(&conf_)) + sizeof(source_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ObstacleRaw::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .CommonProto.Rect rect = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_rect(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required float conf = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          HasBitSetters::set_has_conf(&has_bits);
          conf_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required int32 model = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_model(&has_bits);
          model_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 source = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_source(&has_bits);
          source_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 property = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_property(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 48);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(mutable_property(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string property_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(add_property_name(), ptr, ctx, "CommonProto.ObstacleRaw.property_name");
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 58);
        } else goto handle_unusual;
        continue;
      // repeated int32 property_type = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_property_type(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 64);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(mutable_property_type(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ObstacleRaw::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.ObstacleRaw)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .CommonProto.Rect rect = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_rect()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float conf = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_conf(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &conf_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 model = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_model(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &model_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 source = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_source(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &source_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 property = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 1, 48u, input, this->mutable_property())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_property())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string property_name = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->add_property_name()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->property_name(this->property_name_size() - 1).data(),
            static_cast<int>(this->property_name(this->property_name_size() - 1).length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "CommonProto.ObstacleRaw.property_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 property_type = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 1, 64u, input, this->mutable_property_type())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (66 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_property_type())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.ObstacleRaw)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.ObstacleRaw)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ObstacleRaw::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.ObstacleRaw)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .CommonProto.Rect rect = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::rect(this), output);
  }

  // required float conf = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(2, this->conf(), output);
  }

  // required int32 model = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->model(), output);
  }

  // optional int32 source = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->source(), output);
  }

  // repeated int32 property = 6;
  for (int i = 0, n = this->property_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(
      6, this->property(i), output);
  }

  // repeated string property_name = 7;
  for (int i = 0, n = this->property_name_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->property_name(i).data(), static_cast<int>(this->property_name(i).length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CommonProto.ObstacleRaw.property_name");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteString(
      7, this->property_name(i), output);
  }

  // repeated int32 property_type = 8;
  for (int i = 0, n = this->property_type_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(
      8, this->property_type(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.ObstacleRaw)
}

::PROTOBUF_NAMESPACE_ID::uint8* ObstacleRaw::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.ObstacleRaw)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .CommonProto.Rect rect = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::rect(this), target);
  }

  // required float conf = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->conf(), target);
  }

  // required int32 model = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->model(), target);
  }

  // optional int32 source = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->source(), target);
  }

  // repeated int32 property = 6;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteInt32ToArray(6, this->property_, target);

  // repeated string property_name = 7;
  for (int i = 0, n = this->property_name_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->property_name(i).data(), static_cast<int>(this->property_name(i).length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CommonProto.ObstacleRaw.property_name");
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      WriteStringToArray(7, this->property_name(i), target);
  }

  // repeated int32 property_type = 8;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteInt32ToArray(8, this->property_type_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.ObstacleRaw)
  return target;
}

size_t ObstacleRaw::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:CommonProto.ObstacleRaw)
  size_t total_size = 0;

  if (has_rect()) {
    // required .CommonProto.Rect rect = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *rect_);
  }

  if (has_conf()) {
    // required float conf = 2;
    total_size += 1 + 4;
  }

  if (has_model()) {
    // required int32 model = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->model());
  }

  return total_size;
}
size_t ObstacleRaw::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CommonProto.ObstacleRaw)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .CommonProto.Rect rect = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *rect_);

    // required float conf = 2;
    total_size += 1 + 4;

    // required int32 model = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->model());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 property = 6;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->property_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->property_size());
    total_size += data_size;
  }

  // repeated string property_name = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->property_name_size());
  for (int i = 0, n = this->property_name_size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      this->property_name(i));
  }

  // repeated int32 property_type = 8;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->property_type_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->property_type_size());
    total_size += data_size;
  }

  // optional int32 source = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->source());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ObstacleRaw::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CommonProto.ObstacleRaw)
  GOOGLE_DCHECK_NE(&from, this);
  const ObstacleRaw* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ObstacleRaw>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CommonProto.ObstacleRaw)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CommonProto.ObstacleRaw)
    MergeFrom(*source);
  }
}

void ObstacleRaw::MergeFrom(const ObstacleRaw& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CommonProto.ObstacleRaw)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  property_.MergeFrom(from.property_);
  property_name_.MergeFrom(from.property_name_);
  property_type_.MergeFrom(from.property_type_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_rect()->::CommonProto::Rect::MergeFrom(from.rect());
    }
    if (cached_has_bits & 0x00000002u) {
      conf_ = from.conf_;
    }
    if (cached_has_bits & 0x00000004u) {
      model_ = from.model_;
    }
    if (cached_has_bits & 0x00000008u) {
      source_ = from.source_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ObstacleRaw::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CommonProto.ObstacleRaw)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ObstacleRaw::CopyFrom(const ObstacleRaw& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CommonProto.ObstacleRaw)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObstacleRaw::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  if (has_rect()) {
    if (!this->rect_->IsInitialized()) return false;
  }
  return true;
}

void ObstacleRaw::Swap(ObstacleRaw* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObstacleRaw::InternalSwap(ObstacleRaw* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  property_.InternalSwap(&other->property_);
  property_name_.InternalSwap(CastToBase(&other->property_name_));
  property_type_.InternalSwap(&other->property_type_);
  swap(rect_, other->rect_);
  swap(conf_, other->conf_);
  swap(model_, other->model_);
  swap(source_, other->source_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ObstacleRaw::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ObstacleRaws::InitAsDefaultInstance() {
}
class ObstacleRaws::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<ObstacleRaws>()._has_bits_);
  static void set_has_cam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_conf_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ObstacleRaws::kCamIdFieldNumber;
const int ObstacleRaws::kObstacleFieldNumber;
const int ObstacleRaws::kConfScaleFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObstacleRaws::ObstacleRaws()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.ObstacleRaws)
}
ObstacleRaws::ObstacleRaws(const ObstacleRaws& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      obstacle_(from.obstacle_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&cam_id_, &from.cam_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&conf_scale_) -
    reinterpret_cast<char*>(&cam_id_)) + sizeof(conf_scale_));
  // @@protoc_insertion_point(copy_constructor:CommonProto.ObstacleRaws)
}

void ObstacleRaws::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ObstacleRaws_common_2eproto.base);
  cam_id_ = 0;
  conf_scale_ = 0.1f;
}

ObstacleRaws::~ObstacleRaws() {
  // @@protoc_insertion_point(destructor:CommonProto.ObstacleRaws)
  SharedDtor();
}

void ObstacleRaws::SharedDtor() {
}

void ObstacleRaws::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ObstacleRaws& ObstacleRaws::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ObstacleRaws_common_2eproto.base);
  return *internal_default_instance();
}


void ObstacleRaws::Clear() {
// @@protoc_insertion_point(message_clear_start:CommonProto.ObstacleRaws)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  obstacle_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    cam_id_ = 0;
    conf_scale_ = 0.1f;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ObstacleRaws::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 cam_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          HasBitSetters::set_has_cam_id(&has_bits);
          cam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .CommonProto.ObstacleRaw obstacle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_obstacle(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      // optional float conf_scale = 3 [default = 0.1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          HasBitSetters::set_has_conf_scale(&has_bits);
          conf_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ObstacleRaws::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.ObstacleRaws)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 cam_id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_cam_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &cam_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .CommonProto.ObstacleRaw obstacle = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_obstacle()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float conf_scale = 3 [default = 0.1];
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_conf_scale(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &conf_scale_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.ObstacleRaws)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.ObstacleRaws)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ObstacleRaws::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.ObstacleRaws)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 cam_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->cam_id(), output);
  }

  // repeated .CommonProto.ObstacleRaw obstacle = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->obstacle_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->obstacle(static_cast<int>(i)),
      output);
  }

  // optional float conf_scale = 3 [default = 0.1];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(3, this->conf_scale(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.ObstacleRaws)
}

::PROTOBUF_NAMESPACE_ID::uint8* ObstacleRaws::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.ObstacleRaws)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 cam_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->cam_id(), target);
  }

  // repeated .CommonProto.ObstacleRaw obstacle = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->obstacle_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->obstacle(static_cast<int>(i)), target);
  }

  // optional float conf_scale = 3 [default = 0.1];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->conf_scale(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.ObstacleRaws)
  return target;
}

size_t ObstacleRaws::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CommonProto.ObstacleRaws)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CommonProto.ObstacleRaw obstacle = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->obstacle_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->obstacle(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 cam_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->cam_id());
    }

    // optional float conf_scale = 3 [default = 0.1];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ObstacleRaws::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CommonProto.ObstacleRaws)
  GOOGLE_DCHECK_NE(&from, this);
  const ObstacleRaws* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ObstacleRaws>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CommonProto.ObstacleRaws)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CommonProto.ObstacleRaws)
    MergeFrom(*source);
  }
}

void ObstacleRaws::MergeFrom(const ObstacleRaws& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CommonProto.ObstacleRaws)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  obstacle_.MergeFrom(from.obstacle_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      cam_id_ = from.cam_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      conf_scale_ = from.conf_scale_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ObstacleRaws::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CommonProto.ObstacleRaws)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ObstacleRaws::CopyFrom(const ObstacleRaws& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CommonProto.ObstacleRaws)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObstacleRaws::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->obstacle())) return false;
  return true;
}

void ObstacleRaws::Swap(ObstacleRaws* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObstacleRaws::InternalSwap(ObstacleRaws* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&obstacle_)->InternalSwap(CastToBase(&other->obstacle_));
  swap(cam_id_, other->cam_id_);
  swap(conf_scale_, other->conf_scale_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ObstacleRaws::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void CameraMatrix::InitAsDefaultInstance() {
}
class CameraMatrix::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<CameraMatrix>()._has_bits_);
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CameraMatrix::kMatGnd2ImgFieldNumber;
const int CameraMatrix::kMatImg2GndFieldNumber;
const int CameraMatrix::kMatVcsgnd2ImgFieldNumber;
const int CameraMatrix::kMatImg2VcsgndFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CameraMatrix::CameraMatrix()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.CameraMatrix)
}
CameraMatrix::CameraMatrix(const CameraMatrix& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      mat_gnd2img_(from.mat_gnd2img_),
      mat_img2gnd_(from.mat_img2gnd_),
      mat_vcsgnd2img_(from.mat_vcsgnd2img_),
      mat_img2vcsgnd_(from.mat_img2vcsgnd_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CommonProto.CameraMatrix)
}

void CameraMatrix::SharedCtor() {
}

CameraMatrix::~CameraMatrix() {
  // @@protoc_insertion_point(destructor:CommonProto.CameraMatrix)
  SharedDtor();
}

void CameraMatrix::SharedDtor() {
}

void CameraMatrix::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CameraMatrix& CameraMatrix::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CameraMatrix_common_2eproto.base);
  return *internal_default_instance();
}


void CameraMatrix::Clear() {
// @@protoc_insertion_point(message_clear_start:CommonProto.CameraMatrix)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mat_gnd2img_.Clear();
  mat_img2gnd_.Clear();
  mat_vcsgnd2img_.Clear();
  mat_img2vcsgnd_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CameraMatrix::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated float mat_gnd2img = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_mat_gnd2img(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 13);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(mutable_mat_gnd2img(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated float mat_img2gnd = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_mat_img2gnd(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 21);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(mutable_mat_img2gnd(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated float mat_vcsgnd2img = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_mat_vcsgnd2img(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 29);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(mutable_mat_vcsgnd2img(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated float mat_img2vcsgnd = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_mat_img2vcsgnd(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 37);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(mutable_mat_img2vcsgnd(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CameraMatrix::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.CameraMatrix)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float mat_gnd2img = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (13 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 13u, input, this->mutable_mat_gnd2img())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_mat_gnd2img())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated float mat_img2gnd = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (21 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 21u, input, this->mutable_mat_img2gnd())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_mat_img2gnd())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated float mat_vcsgnd2img = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (29 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 29u, input, this->mutable_mat_vcsgnd2img())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_mat_vcsgnd2img())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated float mat_img2vcsgnd = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (37 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 37u, input, this->mutable_mat_img2vcsgnd())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_mat_img2vcsgnd())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.CameraMatrix)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.CameraMatrix)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CameraMatrix::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.CameraMatrix)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float mat_gnd2img = 1;
  for (int i = 0, n = this->mat_gnd2img_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(
      1, this->mat_gnd2img(i), output);
  }

  // repeated float mat_img2gnd = 2;
  for (int i = 0, n = this->mat_img2gnd_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(
      2, this->mat_img2gnd(i), output);
  }

  // repeated float mat_vcsgnd2img = 3;
  for (int i = 0, n = this->mat_vcsgnd2img_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(
      3, this->mat_vcsgnd2img(i), output);
  }

  // repeated float mat_img2vcsgnd = 4;
  for (int i = 0, n = this->mat_img2vcsgnd_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(
      4, this->mat_img2vcsgnd(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.CameraMatrix)
}

::PROTOBUF_NAMESPACE_ID::uint8* CameraMatrix::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.CameraMatrix)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float mat_gnd2img = 1;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteFloatToArray(1, this->mat_gnd2img_, target);

  // repeated float mat_img2gnd = 2;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteFloatToArray(2, this->mat_img2gnd_, target);

  // repeated float mat_vcsgnd2img = 3;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteFloatToArray(3, this->mat_vcsgnd2img_, target);

  // repeated float mat_img2vcsgnd = 4;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteFloatToArray(4, this->mat_img2vcsgnd_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.CameraMatrix)
  return target;
}

size_t CameraMatrix::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CommonProto.CameraMatrix)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float mat_gnd2img = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->mat_gnd2img_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->mat_gnd2img_size());
    total_size += data_size;
  }

  // repeated float mat_img2gnd = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->mat_img2gnd_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->mat_img2gnd_size());
    total_size += data_size;
  }

  // repeated float mat_vcsgnd2img = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->mat_vcsgnd2img_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->mat_vcsgnd2img_size());
    total_size += data_size;
  }

  // repeated float mat_img2vcsgnd = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->mat_img2vcsgnd_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->mat_img2vcsgnd_size());
    total_size += data_size;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CameraMatrix::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CommonProto.CameraMatrix)
  GOOGLE_DCHECK_NE(&from, this);
  const CameraMatrix* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CameraMatrix>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CommonProto.CameraMatrix)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CommonProto.CameraMatrix)
    MergeFrom(*source);
  }
}

void CameraMatrix::MergeFrom(const CameraMatrix& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CommonProto.CameraMatrix)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  mat_gnd2img_.MergeFrom(from.mat_gnd2img_);
  mat_img2gnd_.MergeFrom(from.mat_img2gnd_);
  mat_vcsgnd2img_.MergeFrom(from.mat_vcsgnd2img_);
  mat_img2vcsgnd_.MergeFrom(from.mat_img2vcsgnd_);
}

void CameraMatrix::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CommonProto.CameraMatrix)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CameraMatrix::CopyFrom(const CameraMatrix& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CommonProto.CameraMatrix)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraMatrix::IsInitialized() const {
  return true;
}

void CameraMatrix::Swap(CameraMatrix* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CameraMatrix::InternalSwap(CameraMatrix* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  mat_gnd2img_.InternalSwap(&other->mat_gnd2img_);
  mat_img2gnd_.InternalSwap(&other->mat_img2gnd_);
  mat_vcsgnd2img_.InternalSwap(&other->mat_vcsgnd2img_);
  mat_img2vcsgnd_.InternalSwap(&other->mat_img2vcsgnd_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CameraMatrix::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void DistortParam::InitAsDefaultInstance() {
}
class DistortParam::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<DistortParam>()._has_bits_);
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DistortParam::kParamFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DistortParam::DistortParam()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.DistortParam)
}
DistortParam::DistortParam(const DistortParam& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      param_(from.param_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CommonProto.DistortParam)
}

void DistortParam::SharedCtor() {
}

DistortParam::~DistortParam() {
  // @@protoc_insertion_point(destructor:CommonProto.DistortParam)
  SharedDtor();
}

void DistortParam::SharedDtor() {
}

void DistortParam::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DistortParam& DistortParam::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DistortParam_common_2eproto.base);
  return *internal_default_instance();
}


void DistortParam::Clear() {
// @@protoc_insertion_point(message_clear_start:CommonProto.DistortParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  param_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* DistortParam::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated float param = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_param(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 13);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(mutable_param(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool DistortParam::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.DistortParam)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float param = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (13 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 13u, input, this->mutable_param())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_param())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.DistortParam)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.DistortParam)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void DistortParam::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.DistortParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float param = 1;
  for (int i = 0, n = this->param_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(
      1, this->param(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.DistortParam)
}

::PROTOBUF_NAMESPACE_ID::uint8* DistortParam::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.DistortParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float param = 1;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteFloatToArray(1, this->param_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.DistortParam)
  return target;
}

size_t DistortParam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CommonProto.DistortParam)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float param = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->param_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->param_size());
    total_size += data_size;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DistortParam::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CommonProto.DistortParam)
  GOOGLE_DCHECK_NE(&from, this);
  const DistortParam* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<DistortParam>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CommonProto.DistortParam)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CommonProto.DistortParam)
    MergeFrom(*source);
  }
}

void DistortParam::MergeFrom(const DistortParam& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CommonProto.DistortParam)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  param_.MergeFrom(from.param_);
}

void DistortParam::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CommonProto.DistortParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DistortParam::CopyFrom(const DistortParam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CommonProto.DistortParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DistortParam::IsInitialized() const {
  return true;
}

void DistortParam::Swap(DistortParam* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DistortParam::InternalSwap(DistortParam* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  param_.InternalSwap(&other->param_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DistortParam::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void VCSParam::InitAsDefaultInstance() {
}
class VCSParam::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<VCSParam>()._has_bits_);
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VCSParam::kRotationFieldNumber;
const int VCSParam::kTranslationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VCSParam::VCSParam()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.VCSParam)
}
VCSParam::VCSParam(const VCSParam& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      rotation_(from.rotation_),
      translation_(from.translation_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CommonProto.VCSParam)
}

void VCSParam::SharedCtor() {
}

VCSParam::~VCSParam() {
  // @@protoc_insertion_point(destructor:CommonProto.VCSParam)
  SharedDtor();
}

void VCSParam::SharedDtor() {
}

void VCSParam::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const VCSParam& VCSParam::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_VCSParam_common_2eproto.base);
  return *internal_default_instance();
}


void VCSParam::Clear() {
// @@protoc_insertion_point(message_clear_start:CommonProto.VCSParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  rotation_.Clear();
  translation_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* VCSParam::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated float rotation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_rotation(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 13);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(mutable_rotation(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated float translation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_translation(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 21);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(mutable_translation(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool VCSParam::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.VCSParam)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float rotation = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (13 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 13u, input, this->mutable_rotation())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_rotation())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated float translation = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (21 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 21u, input, this->mutable_translation())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_translation())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.VCSParam)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.VCSParam)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void VCSParam::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.VCSParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float rotation = 1;
  for (int i = 0, n = this->rotation_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(
      1, this->rotation(i), output);
  }

  // repeated float translation = 2;
  for (int i = 0, n = this->translation_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(
      2, this->translation(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.VCSParam)
}

::PROTOBUF_NAMESPACE_ID::uint8* VCSParam::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.VCSParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float rotation = 1;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteFloatToArray(1, this->rotation_, target);

  // repeated float translation = 2;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteFloatToArray(2, this->translation_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.VCSParam)
  return target;
}

size_t VCSParam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CommonProto.VCSParam)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float rotation = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->rotation_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->rotation_size());
    total_size += data_size;
  }

  // repeated float translation = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->translation_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->translation_size());
    total_size += data_size;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VCSParam::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CommonProto.VCSParam)
  GOOGLE_DCHECK_NE(&from, this);
  const VCSParam* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<VCSParam>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CommonProto.VCSParam)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CommonProto.VCSParam)
    MergeFrom(*source);
  }
}

void VCSParam::MergeFrom(const VCSParam& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CommonProto.VCSParam)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  rotation_.MergeFrom(from.rotation_);
  translation_.MergeFrom(from.translation_);
}

void VCSParam::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CommonProto.VCSParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VCSParam::CopyFrom(const VCSParam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CommonProto.VCSParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VCSParam::IsInitialized() const {
  return true;
}

void VCSParam::Swap(VCSParam* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VCSParam::InternalSwap(VCSParam* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  rotation_.InternalSwap(&other->rotation_);
  translation_.InternalSwap(&other->translation_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VCSParam::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void CameraParam::InitAsDefaultInstance() {
  ::CommonProto::_CameraParam_default_instance_._instance.get_mutable()->distort_ = const_cast< ::CommonProto::DistortParam*>(
      ::CommonProto::DistortParam::internal_default_instance());
  ::CommonProto::_CameraParam_default_instance_._instance.get_mutable()->vcs_ = const_cast< ::CommonProto::VCSParam*>(
      ::CommonProto::VCSParam::internal_default_instance());
  ::CommonProto::_CameraParam_default_instance_._instance.get_mutable()->mat_ = const_cast< ::CommonProto::CameraMatrix*>(
      ::CommonProto::CameraMatrix::internal_default_instance());
}
class CameraParam::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<CameraParam>()._has_bits_);
  static void set_has_focal_u(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_focal_v(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_center_u(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_center_v(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_camera_x(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_camera_y(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_camera_z(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_pitch(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_yaw(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_roll(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_fov(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::CommonProto::DistortParam& distort(const CameraParam* msg);
  static void set_has_distort(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CommonProto::VCSParam& vcs(const CameraParam* msg);
  static void set_has_vcs(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CommonProto::CameraMatrix& mat(const CameraParam* msg);
  static void set_has_mat(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CommonProto::DistortParam&
CameraParam::HasBitSetters::distort(const CameraParam* msg) {
  return *msg->distort_;
}
const ::CommonProto::VCSParam&
CameraParam::HasBitSetters::vcs(const CameraParam* msg) {
  return *msg->vcs_;
}
const ::CommonProto::CameraMatrix&
CameraParam::HasBitSetters::mat(const CameraParam* msg) {
  return *msg->mat_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CameraParam::kFocalUFieldNumber;
const int CameraParam::kFocalVFieldNumber;
const int CameraParam::kCenterUFieldNumber;
const int CameraParam::kCenterVFieldNumber;
const int CameraParam::kCameraXFieldNumber;
const int CameraParam::kCameraYFieldNumber;
const int CameraParam::kCameraZFieldNumber;
const int CameraParam::kPitchFieldNumber;
const int CameraParam::kYawFieldNumber;
const int CameraParam::kRollFieldNumber;
const int CameraParam::kTypeFieldNumber;
const int CameraParam::kFovFieldNumber;
const int CameraParam::kDistortFieldNumber;
const int CameraParam::kVcsFieldNumber;
const int CameraParam::kMatFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CameraParam::CameraParam()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.CameraParam)
}
CameraParam::CameraParam(const CameraParam& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_distort()) {
    distort_ = new ::CommonProto::DistortParam(*from.distort_);
  } else {
    distort_ = nullptr;
  }
  if (from.has_vcs()) {
    vcs_ = new ::CommonProto::VCSParam(*from.vcs_);
  } else {
    vcs_ = nullptr;
  }
  if (from.has_mat()) {
    mat_ = new ::CommonProto::CameraMatrix(*from.mat_);
  } else {
    mat_ = nullptr;
  }
  ::memcpy(&focal_u_, &from.focal_u_,
    static_cast<size_t>(reinterpret_cast<char*>(&fov_) -
    reinterpret_cast<char*>(&focal_u_)) + sizeof(fov_));
  // @@protoc_insertion_point(copy_constructor:CommonProto.CameraParam)
}

void CameraParam::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CameraParam_common_2eproto.base);
  ::memset(&distort_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&fov_) -
      reinterpret_cast<char*>(&distort_)) + sizeof(fov_));
}

CameraParam::~CameraParam() {
  // @@protoc_insertion_point(destructor:CommonProto.CameraParam)
  SharedDtor();
}

void CameraParam::SharedDtor() {
  if (this != internal_default_instance()) delete distort_;
  if (this != internal_default_instance()) delete vcs_;
  if (this != internal_default_instance()) delete mat_;
}

void CameraParam::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CameraParam& CameraParam::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CameraParam_common_2eproto.base);
  return *internal_default_instance();
}


void CameraParam::Clear() {
// @@protoc_insertion_point(message_clear_start:CommonProto.CameraParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(distort_ != nullptr);
      distort_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(vcs_ != nullptr);
      vcs_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(mat_ != nullptr);
      mat_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&focal_u_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&camera_x_) -
        reinterpret_cast<char*>(&focal_u_)) + sizeof(camera_x_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&camera_y_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fov_) -
        reinterpret_cast<char*>(&camera_y_)) + sizeof(fov_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CameraParam::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required float focal_u = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          HasBitSetters::set_has_focal_u(&has_bits);
          focal_u_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float focal_v = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          HasBitSetters::set_has_focal_v(&has_bits);
          focal_v_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float center_u = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          HasBitSetters::set_has_center_u(&has_bits);
          center_u_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float center_v = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          HasBitSetters::set_has_center_v(&has_bits);
          center_v_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float camera_x = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          HasBitSetters::set_has_camera_x(&has_bits);
          camera_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float camera_y = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          HasBitSetters::set_has_camera_y(&has_bits);
          camera_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float camera_z = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          HasBitSetters::set_has_camera_z(&has_bits);
          camera_z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float pitch = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          HasBitSetters::set_has_pitch(&has_bits);
          pitch_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float yaw = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          HasBitSetters::set_has_yaw(&has_bits);
          yaw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float roll = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          HasBitSetters::set_has_roll(&has_bits);
          roll_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 type = 11 [default = 0];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          HasBitSetters::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float fov = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 101)) {
          HasBitSetters::set_has_fov(&has_bits);
          fov_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .CommonProto.DistortParam distort = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr = ctx->ParseMessage(mutable_distort(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CommonProto.VCSParam vcs = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 170)) {
          ptr = ctx->ParseMessage(mutable_vcs(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CommonProto.CameraMatrix mat = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 242)) {
          ptr = ctx->ParseMessage(mutable_mat(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CameraParam::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.CameraParam)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float focal_u = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (13 & 0xFF)) {
          HasBitSetters::set_has_focal_u(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &focal_u_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float focal_v = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_focal_v(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &focal_v_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float center_u = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_center_u(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &center_u_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float center_v = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (37 & 0xFF)) {
          HasBitSetters::set_has_center_v(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &center_v_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float camera_x = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (45 & 0xFF)) {
          HasBitSetters::set_has_camera_x(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &camera_x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float camera_y = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (53 & 0xFF)) {
          HasBitSetters::set_has_camera_y(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &camera_y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float camera_z = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (61 & 0xFF)) {
          HasBitSetters::set_has_camera_z(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &camera_z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float pitch = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (69 & 0xFF)) {
          HasBitSetters::set_has_pitch(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pitch_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float yaw = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (77 & 0xFF)) {
          HasBitSetters::set_has_yaw(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &yaw_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float roll = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (85 & 0xFF)) {
          HasBitSetters::set_has_roll(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &roll_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 type = 11 [default = 0];
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (88 & 0xFF)) {
          HasBitSetters::set_has_type(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float fov = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (101 & 0xFF)) {
          HasBitSetters::set_has_fov(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &fov_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .CommonProto.DistortParam distort = 20;
      case 20: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (162 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_distort()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .CommonProto.VCSParam vcs = 21;
      case 21: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (170 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_vcs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .CommonProto.CameraMatrix mat = 30;
      case 30: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (242 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_mat()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.CameraParam)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.CameraParam)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CameraParam::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.CameraParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required float focal_u = 1;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(1, this->focal_u(), output);
  }

  // required float focal_v = 2;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(2, this->focal_v(), output);
  }

  // required float center_u = 3;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(3, this->center_u(), output);
  }

  // required float center_v = 4;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(4, this->center_v(), output);
  }

  // required float camera_x = 5;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(5, this->camera_x(), output);
  }

  // required float camera_y = 6;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(6, this->camera_y(), output);
  }

  // required float camera_z = 7;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(7, this->camera_z(), output);
  }

  // required float pitch = 8;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(8, this->pitch(), output);
  }

  // required float yaw = 9;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(9, this->yaw(), output);
  }

  // required float roll = 10;
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(10, this->roll(), output);
  }

  // optional int32 type = 11 [default = 0];
  if (cached_has_bits & 0x00002000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(11, this->type(), output);
  }

  // optional float fov = 12;
  if (cached_has_bits & 0x00004000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(12, this->fov(), output);
  }

  // optional .CommonProto.DistortParam distort = 20;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      20, HasBitSetters::distort(this), output);
  }

  // optional .CommonProto.VCSParam vcs = 21;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      21, HasBitSetters::vcs(this), output);
  }

  // optional .CommonProto.CameraMatrix mat = 30;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      30, HasBitSetters::mat(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.CameraParam)
}

::PROTOBUF_NAMESPACE_ID::uint8* CameraParam::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.CameraParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required float focal_u = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->focal_u(), target);
  }

  // required float focal_v = 2;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->focal_v(), target);
  }

  // required float center_u = 3;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->center_u(), target);
  }

  // required float center_v = 4;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->center_v(), target);
  }

  // required float camera_x = 5;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->camera_x(), target);
  }

  // required float camera_y = 6;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->camera_y(), target);
  }

  // required float camera_z = 7;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->camera_z(), target);
  }

  // required float pitch = 8;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->pitch(), target);
  }

  // required float yaw = 9;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->yaw(), target);
  }

  // required float roll = 10;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->roll(), target);
  }

  // optional int32 type = 11 [default = 0];
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->type(), target);
  }

  // optional float fov = 12;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(12, this->fov(), target);
  }

  // optional .CommonProto.DistortParam distort = 20;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        20, HasBitSetters::distort(this), target);
  }

  // optional .CommonProto.VCSParam vcs = 21;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        21, HasBitSetters::vcs(this), target);
  }

  // optional .CommonProto.CameraMatrix mat = 30;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        30, HasBitSetters::mat(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.CameraParam)
  return target;
}

size_t CameraParam::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:CommonProto.CameraParam)
  size_t total_size = 0;

  if (has_focal_u()) {
    // required float focal_u = 1;
    total_size += 1 + 4;
  }

  if (has_focal_v()) {
    // required float focal_v = 2;
    total_size += 1 + 4;
  }

  if (has_center_u()) {
    // required float center_u = 3;
    total_size += 1 + 4;
  }

  if (has_center_v()) {
    // required float center_v = 4;
    total_size += 1 + 4;
  }

  if (has_camera_x()) {
    // required float camera_x = 5;
    total_size += 1 + 4;
  }

  if (has_camera_y()) {
    // required float camera_y = 6;
    total_size += 1 + 4;
  }

  if (has_camera_z()) {
    // required float camera_z = 7;
    total_size += 1 + 4;
  }

  if (has_pitch()) {
    // required float pitch = 8;
    total_size += 1 + 4;
  }

  if (has_yaw()) {
    // required float yaw = 9;
    total_size += 1 + 4;
  }

  if (has_roll()) {
    // required float roll = 10;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t CameraParam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CommonProto.CameraParam)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00001ff8) ^ 0x00001ff8) == 0) {  // All required fields are present.
    // required float focal_u = 1;
    total_size += 1 + 4;

    // required float focal_v = 2;
    total_size += 1 + 4;

    // required float center_u = 3;
    total_size += 1 + 4;

    // required float center_v = 4;
    total_size += 1 + 4;

    // required float camera_x = 5;
    total_size += 1 + 4;

    // required float camera_y = 6;
    total_size += 1 + 4;

    // required float camera_z = 7;
    total_size += 1 + 4;

    // required float pitch = 8;
    total_size += 1 + 4;

    // required float yaw = 9;
    total_size += 1 + 4;

    // required float roll = 10;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CommonProto.DistortParam distort = 20;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *distort_);
    }

    // optional .CommonProto.VCSParam vcs = 21;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *vcs_);
    }

    // optional .CommonProto.CameraMatrix mat = 30;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *mat_);
    }

  }
  if (cached_has_bits & 0x00006000u) {
    // optional int32 type = 11 [default = 0];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional float fov = 12;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CameraParam::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CommonProto.CameraParam)
  GOOGLE_DCHECK_NE(&from, this);
  const CameraParam* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CameraParam>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CommonProto.CameraParam)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CommonProto.CameraParam)
    MergeFrom(*source);
  }
}

void CameraParam::MergeFrom(const CameraParam& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CommonProto.CameraParam)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_distort()->::CommonProto::DistortParam::MergeFrom(from.distort());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_vcs()->::CommonProto::VCSParam::MergeFrom(from.vcs());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_mat()->::CommonProto::CameraMatrix::MergeFrom(from.mat());
    }
    if (cached_has_bits & 0x00000008u) {
      focal_u_ = from.focal_u_;
    }
    if (cached_has_bits & 0x00000010u) {
      focal_v_ = from.focal_v_;
    }
    if (cached_has_bits & 0x00000020u) {
      center_u_ = from.center_u_;
    }
    if (cached_has_bits & 0x00000040u) {
      center_v_ = from.center_v_;
    }
    if (cached_has_bits & 0x00000080u) {
      camera_x_ = from.camera_x_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      camera_y_ = from.camera_y_;
    }
    if (cached_has_bits & 0x00000200u) {
      camera_z_ = from.camera_z_;
    }
    if (cached_has_bits & 0x00000400u) {
      pitch_ = from.pitch_;
    }
    if (cached_has_bits & 0x00000800u) {
      yaw_ = from.yaw_;
    }
    if (cached_has_bits & 0x00001000u) {
      roll_ = from.roll_;
    }
    if (cached_has_bits & 0x00002000u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00004000u) {
      fov_ = from.fov_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CameraParam::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CommonProto.CameraParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CameraParam::CopyFrom(const CameraParam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CommonProto.CameraParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraParam::IsInitialized() const {
  if ((_has_bits_[0] & 0x00001ff8) != 0x00001ff8) return false;
  return true;
}

void CameraParam::Swap(CameraParam* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CameraParam::InternalSwap(CameraParam* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(distort_, other->distort_);
  swap(vcs_, other->vcs_);
  swap(mat_, other->mat_);
  swap(focal_u_, other->focal_u_);
  swap(focal_v_, other->focal_v_);
  swap(center_u_, other->center_u_);
  swap(center_v_, other->center_v_);
  swap(camera_x_, other->camera_x_);
  swap(camera_y_, other->camera_y_);
  swap(camera_z_, other->camera_z_);
  swap(pitch_, other->pitch_);
  swap(yaw_, other->yaw_);
  swap(roll_, other->roll_);
  swap(type_, other->type_);
  swap(fov_, other->fov_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CameraParam::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Color::InitAsDefaultInstance() {
}
class Color::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<Color>()._has_bits_);
  static void set_has_b(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_g(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_r(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Color::kBFieldNumber;
const int Color::kGFieldNumber;
const int Color::kRFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Color::Color()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.Color)
}
Color::Color(const Color& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&b_, &from.b_,
    static_cast<size_t>(reinterpret_cast<char*>(&r_) -
    reinterpret_cast<char*>(&b_)) + sizeof(r_));
  // @@protoc_insertion_point(copy_constructor:CommonProto.Color)
}

void Color::SharedCtor() {
  ::memset(&b_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&r_) -
      reinterpret_cast<char*>(&b_)) + sizeof(r_));
}

Color::~Color() {
  // @@protoc_insertion_point(destructor:CommonProto.Color)
  SharedDtor();
}

void Color::SharedDtor() {
}

void Color::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Color& Color::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Color_common_2eproto.base);
  return *internal_default_instance();
}


void Color::Clear() {
// @@protoc_insertion_point(message_clear_start:CommonProto.Color)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&b_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&r_) -
        reinterpret_cast<char*>(&b_)) + sizeof(r_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Color::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 b = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          HasBitSetters::set_has_b(&has_bits);
          b_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 g = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_g(&has_bits);
          g_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 r = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_r(&has_bits);
          r_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Color::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.Color)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 b = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_b(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &b_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 g = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_g(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &g_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 r = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_r(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &r_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.Color)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.Color)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Color::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.Color)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 b = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->b(), output);
  }

  // required uint32 g = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->g(), output);
  }

  // required uint32 r = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->r(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.Color)
}

::PROTOBUF_NAMESPACE_ID::uint8* Color::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.Color)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 b = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->b(), target);
  }

  // required uint32 g = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->g(), target);
  }

  // required uint32 r = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->r(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.Color)
  return target;
}

size_t Color::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:CommonProto.Color)
  size_t total_size = 0;

  if (has_b()) {
    // required uint32 b = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->b());
  }

  if (has_g()) {
    // required uint32 g = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->g());
  }

  if (has_r()) {
    // required uint32 r = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->r());
  }

  return total_size;
}
size_t Color::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CommonProto.Color)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 b = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->b());

    // required uint32 g = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->g());

    // required uint32 r = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->r());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Color::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CommonProto.Color)
  GOOGLE_DCHECK_NE(&from, this);
  const Color* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Color>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CommonProto.Color)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CommonProto.Color)
    MergeFrom(*source);
  }
}

void Color::MergeFrom(const Color& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CommonProto.Color)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      b_ = from.b_;
    }
    if (cached_has_bits & 0x00000002u) {
      g_ = from.g_;
    }
    if (cached_has_bits & 0x00000004u) {
      r_ = from.r_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Color::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CommonProto.Color)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Color::CopyFrom(const Color& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CommonProto.Color)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Color::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void Color::Swap(Color* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Color::InternalSwap(Color* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(b_, other->b_);
  swap(g_, other->g_);
  swap(r_, other->r_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Color::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ParsingSetting::InitAsDefaultInstance() {
}
class ParsingSetting::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<ParsingSetting>()._has_bits_);
  static void set_has_parsing_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_parsing_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ParsingSetting::kParsingTypeFieldNumber;
const int ParsingSetting::kParsingChannelsFieldNumber;
const int ParsingSetting::kChannelLabelsFieldNumber;
const int ParsingSetting::kChannelColorsFieldNumber;
const int ParsingSetting::kFreespaceChannelsFieldNumber;
const int ParsingSetting::kBoundspaceChannelsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ParsingSetting::ParsingSetting()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.ParsingSetting)
}
ParsingSetting::ParsingSetting(const ParsingSetting& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      channel_labels_(from.channel_labels_),
      channel_colors_(from.channel_colors_),
      freespace_channels_(from.freespace_channels_),
      boundspace_channels_(from.boundspace_channels_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&parsing_type_, &from.parsing_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&parsing_channels_) -
    reinterpret_cast<char*>(&parsing_type_)) + sizeof(parsing_channels_));
  // @@protoc_insertion_point(copy_constructor:CommonProto.ParsingSetting)
}

void ParsingSetting::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ParsingSetting_common_2eproto.base);
  ::memset(&parsing_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&parsing_channels_) -
      reinterpret_cast<char*>(&parsing_type_)) + sizeof(parsing_channels_));
}

ParsingSetting::~ParsingSetting() {
  // @@protoc_insertion_point(destructor:CommonProto.ParsingSetting)
  SharedDtor();
}

void ParsingSetting::SharedDtor() {
}

void ParsingSetting::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ParsingSetting& ParsingSetting::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ParsingSetting_common_2eproto.base);
  return *internal_default_instance();
}


void ParsingSetting::Clear() {
// @@protoc_insertion_point(message_clear_start:CommonProto.ParsingSetting)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  channel_labels_.Clear();
  channel_colors_.Clear();
  freespace_channels_.Clear();
  boundspace_channels_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&parsing_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&parsing_channels_) -
        reinterpret_cast<char*>(&parsing_type_)) + sizeof(parsing_channels_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ParsingSetting::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required int32 parsing_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          HasBitSetters::set_has_parsing_type(&has_bits);
          parsing_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 parsing_channels = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_parsing_channels(&has_bits);
          parsing_channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint64 channel_labels = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_channel_labels(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 24);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(mutable_channel_labels(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .CommonProto.Color channel_colors = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_channel_colors(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 34);
        } else goto handle_unusual;
        continue;
      // repeated int32 freespace_channels = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_freespace_channels(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 40);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(mutable_freespace_channels(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 boundspace_channels = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_boundspace_channels(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 48);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(mutable_boundspace_channels(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ParsingSetting::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.ParsingSetting)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 parsing_type = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_parsing_type(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &parsing_type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 parsing_channels = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_parsing_channels(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &parsing_channels_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint64 channel_labels = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 1, 24u, input, this->mutable_channel_labels())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_channel_labels())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .CommonProto.Color channel_colors = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_channel_colors()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 freespace_channels = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 1, 40u, input, this->mutable_freespace_channels())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_freespace_channels())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 boundspace_channels = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 1, 48u, input, this->mutable_boundspace_channels())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_boundspace_channels())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.ParsingSetting)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.ParsingSetting)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ParsingSetting::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.ParsingSetting)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 parsing_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->parsing_type(), output);
  }

  // required int32 parsing_channels = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->parsing_channels(), output);
  }

  // repeated uint64 channel_labels = 3;
  for (int i = 0, n = this->channel_labels_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(
      3, this->channel_labels(i), output);
  }

  // repeated .CommonProto.Color channel_colors = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->channel_colors_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      4,
      this->channel_colors(static_cast<int>(i)),
      output);
  }

  // repeated int32 freespace_channels = 5;
  for (int i = 0, n = this->freespace_channels_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(
      5, this->freespace_channels(i), output);
  }

  // repeated int32 boundspace_channels = 6;
  for (int i = 0, n = this->boundspace_channels_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(
      6, this->boundspace_channels(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.ParsingSetting)
}

::PROTOBUF_NAMESPACE_ID::uint8* ParsingSetting::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.ParsingSetting)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 parsing_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->parsing_type(), target);
  }

  // required int32 parsing_channels = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->parsing_channels(), target);
  }

  // repeated uint64 channel_labels = 3;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteUInt64ToArray(3, this->channel_labels_, target);

  // repeated .CommonProto.Color channel_colors = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->channel_colors_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->channel_colors(static_cast<int>(i)), target);
  }

  // repeated int32 freespace_channels = 5;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteInt32ToArray(5, this->freespace_channels_, target);

  // repeated int32 boundspace_channels = 6;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteInt32ToArray(6, this->boundspace_channels_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.ParsingSetting)
  return target;
}

size_t ParsingSetting::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:CommonProto.ParsingSetting)
  size_t total_size = 0;

  if (has_parsing_type()) {
    // required int32 parsing_type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->parsing_type());
  }

  if (has_parsing_channels()) {
    // required int32 parsing_channels = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->parsing_channels());
  }

  return total_size;
}
size_t ParsingSetting::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CommonProto.ParsingSetting)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 parsing_type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->parsing_type());

    // required int32 parsing_channels = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->parsing_channels());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 channel_labels = 3;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->channel_labels_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->channel_labels_size());
    total_size += data_size;
  }

  // repeated .CommonProto.Color channel_colors = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->channel_colors_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->channel_colors(static_cast<int>(i)));
    }
  }

  // repeated int32 freespace_channels = 5;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->freespace_channels_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->freespace_channels_size());
    total_size += data_size;
  }

  // repeated int32 boundspace_channels = 6;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->boundspace_channels_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->boundspace_channels_size());
    total_size += data_size;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ParsingSetting::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CommonProto.ParsingSetting)
  GOOGLE_DCHECK_NE(&from, this);
  const ParsingSetting* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ParsingSetting>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CommonProto.ParsingSetting)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CommonProto.ParsingSetting)
    MergeFrom(*source);
  }
}

void ParsingSetting::MergeFrom(const ParsingSetting& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CommonProto.ParsingSetting)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  channel_labels_.MergeFrom(from.channel_labels_);
  channel_colors_.MergeFrom(from.channel_colors_);
  freespace_channels_.MergeFrom(from.freespace_channels_);
  boundspace_channels_.MergeFrom(from.boundspace_channels_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      parsing_type_ = from.parsing_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      parsing_channels_ = from.parsing_channels_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ParsingSetting::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CommonProto.ParsingSetting)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ParsingSetting::CopyFrom(const ParsingSetting& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CommonProto.ParsingSetting)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParsingSetting::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->channel_colors())) return false;
  return true;
}

void ParsingSetting::Swap(ParsingSetting* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ParsingSetting::InternalSwap(ParsingSetting* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  channel_labels_.InternalSwap(&other->channel_labels_);
  CastToBase(&channel_colors_)->InternalSwap(CastToBase(&other->channel_colors_));
  freespace_channels_.InternalSwap(&other->freespace_channels_);
  boundspace_channels_.InternalSwap(&other->boundspace_channels_);
  swap(parsing_type_, other->parsing_type_);
  swap(parsing_channels_, other->parsing_channels_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ParsingSetting::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace CommonProto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CommonProto::Rect* Arena::CreateMaybeMessage< ::CommonProto::Rect >(Arena* arena) {
  return Arena::CreateInternal< ::CommonProto::Rect >(arena);
}
template<> PROTOBUF_NOINLINE ::CommonProto::Image* Arena::CreateMaybeMessage< ::CommonProto::Image >(Arena* arena) {
  return Arena::CreateInternal< ::CommonProto::Image >(arena);
}
template<> PROTOBUF_NOINLINE ::CommonProto::ObstacleRaw* Arena::CreateMaybeMessage< ::CommonProto::ObstacleRaw >(Arena* arena) {
  return Arena::CreateInternal< ::CommonProto::ObstacleRaw >(arena);
}
template<> PROTOBUF_NOINLINE ::CommonProto::ObstacleRaws* Arena::CreateMaybeMessage< ::CommonProto::ObstacleRaws >(Arena* arena) {
  return Arena::CreateInternal< ::CommonProto::ObstacleRaws >(arena);
}
template<> PROTOBUF_NOINLINE ::CommonProto::CameraMatrix* Arena::CreateMaybeMessage< ::CommonProto::CameraMatrix >(Arena* arena) {
  return Arena::CreateInternal< ::CommonProto::CameraMatrix >(arena);
}
template<> PROTOBUF_NOINLINE ::CommonProto::DistortParam* Arena::CreateMaybeMessage< ::CommonProto::DistortParam >(Arena* arena) {
  return Arena::CreateInternal< ::CommonProto::DistortParam >(arena);
}
template<> PROTOBUF_NOINLINE ::CommonProto::VCSParam* Arena::CreateMaybeMessage< ::CommonProto::VCSParam >(Arena* arena) {
  return Arena::CreateInternal< ::CommonProto::VCSParam >(arena);
}
template<> PROTOBUF_NOINLINE ::CommonProto::CameraParam* Arena::CreateMaybeMessage< ::CommonProto::CameraParam >(Arena* arena) {
  return Arena::CreateInternal< ::CommonProto::CameraParam >(arena);
}
template<> PROTOBUF_NOINLINE ::CommonProto::Color* Arena::CreateMaybeMessage< ::CommonProto::Color >(Arena* arena) {
  return Arena::CreateInternal< ::CommonProto::Color >(arena);
}
template<> PROTOBUF_NOINLINE ::CommonProto::ParsingSetting* Arena::CreateMaybeMessage< ::CommonProto::ParsingSetting >(Arena* arena) {
  return Arena::CreateInternal< ::CommonProto::ParsingSetting >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
